#include "Dumper.h"
#include "Structs.h"

void DumpBlocks(std::ofstream &gname, kaddr block, uint32 blockIdx, uint32 blockSizeBytes)
{
    // 获取块内 FNameEntry 的起始结束地址
    kaddr It = Tools::getPtr(block + (blockIdx * Offsets.Global.PointerSize));
    kaddr End = It + blockSizeBytes - Offsets.FNameEntry.StringName;
    std::cout << std::hex << "It: 0x" << It << "End: 0x" << End << std::endl;
    uint16 Offset = 0;
    while (It < End)
    {
        // 获取字符串信息
        kaddr FNameEntry = It;
        int16 FNameEntryHeader = Tools::Read<int16>(FNameEntry);
        int StrLength = FNameEntryHeader >> Offsets.FNameEntryHeader.StringLenBit;
        if (StrLength)
        {
            // 解析字符串
            bool wide = FNameEntryHeader & 1;
            if (StrLength > 0)
            {
                std::string str;
                // 字符串编号
                uint32 key = (blockIdx << 16 | Offset);
                kaddr StrPtr = FNameEntry + Offsets.FNameEntry.StringName;

                if (wide)
                    str = Tools::WideStr::readString(StrPtr, StrLength);
                else
                    str = Tools::readString(StrPtr, StrLength);

                gname << "[0x" << std::setfill('0') << std::setw(6) << std::hex << key << "]\t" << std::setw(4)
                      << (wide ? "Wide\t" : "Ansi\t") << "{0x" << std::setfill('0') << std::setw(3) << StrLength
                      << "}\t" << str << std::endl;
            }
            else
            {
                StrLength = -StrLength;
            }

            // 遍历下一个
            uint16 totalBytes = Offsets.FNameEntry.StringName + StrLength * (wide ? sizeof(wchar_t) : sizeof(char));
            uint32 alignedBytes =
                (totalBytes + Offsets.FNameEntryAllocator.Stride - 1u) & ~(Offsets.FNameEntryAllocator.Stride - 1u);

            It += alignedBytes;
            // BlockSizeBytes = Stride * FNameBlockOffsets 为 2 * 0x10000，因此除以 Stride 保证 offset 在一个 block 内部
            // 真实的块内偏移为 Offset * 2
            Offset += alignedBytes / Offsets.FNameEntryAllocator.Stride;
        }
        else
        {
            break;
        }
    }
}

void DumpStrings(std::string outputpath)
{
    std::ofstream gname(outputpath + "/Strings.txt", std::ofstream::out);
    if (gname.is_open())
    {
        // 获取存储 String 的 Block 数组地址
        kaddr FNameEntryAllocator = Tools::getRealOffset(Offsets.Global.GName) + Offsets.FNamePool.Entries;
        uint32 CurrentBlock = Tools::Read<uint32>(FNameEntryAllocator + Offsets.FNameEntryAllocator.CurrentBlock);
        uint32 CurrentByteCursor =
            Tools::Read<uint32>(FNameEntryAllocator + Offsets.FNameEntryAllocator.CurrentByteCursor);
        kaddr Block = FNameEntryAllocator + Offsets.FNameEntryAllocator.Blocks;

        std::cout << "[1] Dumping Strings ---" << std::endl;
        std::cout << "Total Blocks: " << std::dec << (CurrentBlock + 1) << std::endl;
        std::cout << "Strings Format: [Key]\tType\t{Length}\tString" << std::endl;

        gname << "/*\n"
              << " * Generated by czTang\n"
              << " * Generated on: " << Tools::getCurrentTimeString() << "\n"
              << " */\n"
              << std::endl;
        // 处理所有块
        for (uint32 BlockIdx = 0; BlockIdx < CurrentBlock; ++BlockIdx)
        {
            DumpBlocks(gname, Block, BlockIdx, Offsets.FNameEntryAllocator.BlockSizeBytes);
        }
        // 处理最后一个块，因为它的大小可能小于 Offsets.FNameEntryAllocator.BlockSizeBytes，单独处理
        DumpBlocks(gname, Block, CurrentBlock, CurrentByteCursor);
    }
}

std::string GetFNameFromID(uint32 index)
{
    // 获取块和块内偏移
    uint32 Block = index >> Offsets.FNameBlockOffsetBits;
    uint16 Offset = index & (Offsets.FNameBlockOffsets - 1);

    // 获取 FNameEntry
    kaddr FNameEntryAllocator = Tools::getRealOffset(Offsets.Global.GName) + Offsets.FNamePool.Entries;
    kaddr Blocks = FNameEntryAllocator + Offsets.FNameEntryAllocator.Blocks;
    kaddr BlockInstance = Tools::getPtr(Blocks + (Block * Offsets.Global.PointerSize));

    kaddr FNameEntry = BlockInstance + (Offsets.FNameEntryAllocator.Stride * Offset);
    int16 FNameEntryHeader = Tools::Read<int16>(FNameEntry);

    kaddr StrPtr = FNameEntry + Offsets.FNameEntry.StringName;
    int StrLength = FNameEntryHeader >> Offsets.FNameEntryHeader.StringLenBit;
    std::string Name;
    if (StrLength > 0)
    {
        bool wide = FNameEntryHeader & Offsets.FNameEntryHeader.bIsWide;
        if (wide)
        {
            Name = Tools::WideStr::readString(StrPtr, StrLength);
        }
        else
        {
            Name = Tools::readString(StrPtr, StrLength);
        }
        // 移除路径前缀，把最后一个斜杠后的部分作为名称
        // 例如：/Game/Maps/MyMap -> MyMap
        size_t Pos = Name.rfind('/');
        if (Pos != std::string::npos)
        {
            Name = Name.substr(Pos + 1);
        }
        return Name;
    }
    else
    {
        return "None";
    }
}

void DumpActors(std::string outputpath)
{
    std::ofstream actorlist(outputpath + "/Actors.txt", std::ofstream::out);
    if (actorlist.is_open())
    {
        // 获取 UWorld 和 PersistentLevel
        kaddr word = Tools::getPtr(Tools::getRealOffset(Offsets.Global.GWorld));
        kaddr level = Tools::getPtr(word + Offsets.UWorld.PersistentLevel);

        // 获取 Actors 数组和数量
        kaddr actorsArray = Tools::getPtr(level + Offsets.ULevel.AActors);
        uint32 actorsCount = Tools::Read<uint32>(level + Offsets.ULevel.ActorsCount);

        std::cout << "[2] Dumping Actors ---" << std::endl;
        std::cout << "Total Actors: " << actorsCount << std::endl;
        actorlist << "/*\n"
                  << " * Generated by czTang\n"
                  << " * Generated on: " << Tools::getCurrentTimeString() << "\n"
                  << " */\n"
                  << std::endl;

        for (int i = 0; i < actorsCount; i++)
        {
            kaddr actor = Tools::getPtr(actorsArray + (i * Offsets.Global.PointerSize));
            if (UObject::isValid(actor))
            {
                actorlist << "Id: " << std::setw(3) << std::right << std::setbase(10) << i << ", Addr: 0x" << std::hex
                          << actor << ", ActorName: " << UStruct::getCPPName(actor) << std::endl;
            }
        }
    }
}

kaddr GetUObjectFromID(uint32 index)
{
    kaddr TUObjectArray =
        Tools::getPtr(Tools::getRealOffset(Offsets.Global.GUObjectArray) + Offsets.FUObjectArray.ObjObjects);
    kaddr Chunk = Tools::getPtr(TUObjectArray + ((index / Offsets.NumElementsPerChunk) * Offsets.Global.PointerSize));
    return Tools::getPtr(Chunk + Offsets.FUObjectItem.Padd +
                         ((index % Offsets.NumElementsPerChunk) * Offsets.FUObjectItem.Size));
}

int32 GetObjectCount()
{
    return Tools::Read<int32>(Tools::getRealOffset(Offsets.Global.GUObjectArray) + Offsets.FUObjectArray.ObjObjects +
                              Offsets.TUObjectArray.NumElements);
}

std::string GetOuterFullName(kaddr uobj)
{
    std::string fullname = UObject::getName(uobj);
    kaddr Outer = UObject::getOuter(uobj);
    while (Outer)
    {
        fullname = UObject::getName(Outer) + '.' + fullname;
        Outer = UObject::getOuter(Outer);
    }
    return fullname;
}

ObjectType ClassifyObject(kaddr classPtr)
{
    // 遍历继承链，找到是否存在特定的父类
    kaddr currentClass = classPtr;
    while (currentClass)
    {
        if (currentClass == objectFullName.EngineActor)
        {
            return ObjectType::ACTOR;
        }
        else if (currentClass == objectFullName.CoreEnum)
        {
            return ObjectType::ENUM;
        }
        else if (currentClass == objectFullName.CoreClass)
        {
            return ObjectType::CLASS;
        }
        else if (currentClass == objectFullName.CoreFunction)
        {
            return ObjectType::FUNCTION;
        }
        else if (currentClass == objectFullName.CoreScriptStruct)
        {
            return ObjectType::STRUCT;
        }
        currentClass = UStruct::getSuperClass(currentClass);
    }

    return ObjectType::OTHER;
}

std::string FormatPropertyType(kaddr prop)
{
    std::string cname = FField::getClassName(prop);
    // 简单类型处理，只需要返回数据类型
    if (Tools::isEqual(cname, "NameProperty"))
    {
        return "FName";
    }
    else if (Tools::isEqual(cname, "StrProperty"))
    {
        return "FString";
    }
    else if (Tools::isEqual(cname, "TextProperty"))
    {
        return "FText";
    }
    else if (Tools::isEqual(cname, "UInt16Property"))
    {
        return "uint16";
    }
    else if (Tools::isEqual(cname, "UInt32Property"))
    {
        return "uint32";
    }
    else if (Tools::isEqual(cname, "UInt64Property"))
    {
        return "uint64";
    }
    else if (Tools::isEqual(cname, "Int8Property"))
    {
        return "int8";
    }
    else if (Tools::isEqual(cname, "Int16Property"))
    {
        return "int16";
    }
    else if (Tools::isEqual(cname, "IntProperty"))
    {
        return "int32";
    }
    else if (Tools::isEqual(cname, "Int64Property"))
    {
        return "int64";
    }
    else if (Tools::isEqual(cname, "FloatProperty"))
    {
        return "float";
    }
    else if (Tools::isEqual(cname, "DelegateProperty"))
    {
        return "FDelegate";
    }
    else if (Tools::isEqual(cname, "SoftClassProperty"))
    {
        return "TSoftClassPtr<UObject>";
    }
    else if (Tools::isEqual(cname, "MulticastDelegateProperty"))
    {
        return "FMulticastDelegate";
    }
    else if (Tools::isEqual(cname, "MulticastSparseDelegateProperty"))
    {
        return "FMulticastSparseDelegate";
    }
    else if (Tools::isEqual(cname, "MulticastInlineDelegateProperty"))
    {
        return "FMulticastInlineDelegate";
    }

    // 特殊类型处理，需要根据不同类型进行递归等处理
    if (Tools::isEqual(cname, "MapProperty"))
    {
        std::string keyType = FormatPropertyType(FMapProperty::getKeyProp(prop));
        std::string valueType = FormatPropertyType(FMapProperty::getValueProp(prop));
        return "TMap<" + keyType + ", " + valueType + ">";
    }
    else if (Tools::isEqual(cname, "SetProperty"))
    {
        return "TSet<" + FormatPropertyType(FSetProperty::getElementProp(prop)) + ">";
    }
    else if (Tools::isEqual(cname, "EnumProperty"))
    {
        return "enum class " + UObject::getName(FEnumProperty::getEnum(prop));
    }
    else if (Tools::isEqual(cname, "BoolProperty"))
    {
        // 如果是 bool 类型（一个类型用一个字节），直接返回 bool
        if (FBoolProperty::getFieldMask(prop) == 0xFF)
        {
            return "bool";
        }
        // 如果是位域类型（一个类型用一个 bit），返回 ByteOffset 和 FieldMask
        uint32 ByteOffset = FBoolProperty::getByteOffset(prop);
        uint32 FieldMask = FBoolProperty::getFieldMask(prop);
        return "uint8(ByteOffset: " + std::to_string(ByteOffset) + " FieldMask: " + std::to_string(FieldMask) + ")";
    }
    else if (Tools::isEqual(cname, "ByteProperty"))
    {
        if (UObject::isValid(FByteProperty::getEnum(prop)))
            return "enum class " + UObject::getName(FByteProperty::getEnum(prop));
        return "byte";
    }
    else if (Tools::isEqual(cname, "ClassProperty"))
    {
        return UStruct::getCPPName(FClassProperty::getMetaClass(prop)) + "*";
    }
    else if (Tools::isEqual(cname, "StructProperty"))
    {
        return UStruct::getCPPName(FStructProperty::getStruct(prop));
    }
    else if (Tools::isEqual(cname, "InterfaceProperty"))
    {
        return "TScriptInterface<I" + UObject::getName(FInterfaceProperty::getInterfaceClass(prop)) + ">";
    }
    else if (Tools::isEqual(cname, "ObjectPropertyBase"))
    {
        return UStruct::getCPPName(FObjectPropertyBase::getPropertyClass(prop)) + "*";
    }
    else if (Tools::isEqual(cname, "ArrayProperty"))
    {
        return "TArray<" + FormatPropertyType(FArrayProperty::getInner(prop)) + ">";
    }
    else if (Tools::isEqual(cname, "WeakObjectProperty"))
    {
        return "TWeakObjectPtr<" + UStruct::getCPPName(FStructProperty::getStruct(prop)) + ">";
    }
    else if (Tools::isEqual(cname, "SoftObjectProperty"))
    {
        return "TSoftObjectPtr<" + UStruct::getCPPName(FObjectPropertyBase::getPropertyClass(prop)) + ">";
    }

    return FProperty::getPropCPPName(prop) + "*";
}

void DumpSDK(std::string outputpath)
{
    std::ofstream obj(outputpath + "/Objects.txt", std::ofstream::out);
    if (obj.is_open())
    {
        int32 count = GetObjectCount();
        std::cout << "[3] Dumping Objects ---" << std::endl;
        std::cout << "Total Objects: " << count << std::endl;

        obj << "/*\n"
            << " * Generated by czTang\n"
            << " * Generated on: " << Tools::getCurrentTimeString() << "\n"
            << " */\n"
            << std::endl;
        obj << "============ Core Object ==========\n" << std::endl;
        // 遍历查找核心对象
        for (int32 i = 0; i < count; i++)
        {
            kaddr uobj = GetUObjectFromID(i);
            if (UObject::isValid(uobj))
            {
                std::string outerFullName = GetOuterFullName(uobj);

                // 查找并保存核心对象地址
                if (Tools::isEqual(outerFullName, "CoreUObject.Object"))
                {
                    objectFullName.CoreObject = uobj;
                    obj << "CoreUObject.Object: 0x" << std::hex << uobj << std::endl;
                }
                else if (Tools::isEqual(outerFullName, "Engine.Actor"))
                {
                    objectFullName.EngineActor = uobj;
                    obj << "Engine.Actor: 0x" << std::hex << uobj << std::endl;
                }
                else if (Tools::isEqual(outerFullName, "CoreUObject.Enum"))
                {
                    objectFullName.CoreEnum = uobj;
                    obj << "CoreUObject.Enum: 0x" << std::hex << uobj << std::endl;
                }
                else if (Tools::isEqual(outerFullName, "CoreUObject.Class"))
                {
                    objectFullName.CoreClass = uobj;
                    obj << "CoreUObject.Class: 0x" << std::hex << uobj << std::endl;
                }
                else if (Tools::isEqual(outerFullName, "CoreUObject.Function"))
                {
                    objectFullName.CoreFunction = uobj;
                    obj << "CoreUObject.Function: 0x" << std::hex << uobj << std::endl;
                }
                else if (Tools::isEqual(outerFullName, "CoreUObject.ScriptStruct"))
                {
                    objectFullName.CoreScriptStruct = uobj;
                    obj << "CoreUObject.ScriptStruct: 0x" << std::hex << uobj << std::endl;
                }
            }
        }

        // 基于核心对象分类处理所有对象
        obj << "\n====== Object Classification ======\n" << std::endl;
        std::vector<kaddr> enumObjects;
        std::vector<kaddr> classObjects;
        std::vector<kaddr> functionObjects;
        std::vector<kaddr> structObjects;

        int32 actorCount = 0, enumCount = 0, classCount = 0, functionCount = 0, structCount = 0, otherCount = 0;

        for (int32 i = 0; i < count; i++)
        {
            kaddr uobj = GetUObjectFromID(i);
            if (UObject::isValid(uobj))
            {
                kaddr classPtr = UObject::getClass(uobj);
                std::string className = UObject::getClassName(uobj);
                std::string objectName = UObject::getName(uobj);

                ObjectType objType = ClassifyObject(classPtr);

                obj << "[0x" << std::setfill('0') << std::setw(5) << std::hex << i << "] " << "Ptr: 0x" << std::hex
                    << uobj << " ";

                switch (objType)
                {
                case ObjectType::ACTOR:
                    obj << "[ACTOR] " << objectName << " (" << className << ")" << std::endl;
                    actorCount++;
                    break;

                case ObjectType::ENUM:
                    obj << "[ENUM] " << objectName << std::endl;
                    enumObjects.push_back(uobj);
                    enumCount++;
                    break;

                case ObjectType::CLASS:
                    obj << "[CLASS] " << objectName << std::endl;
                    classObjects.push_back(uobj);
                    classCount++;
                    break;

                case ObjectType::FUNCTION:
                    obj << "[FUNCTION] " << objectName << " in " << className << std::endl;
                    functionObjects.push_back(uobj);
                    functionCount++;
                    break;

                case ObjectType::STRUCT:
                    obj << "[STRUCT] " << objectName << std::endl;
                    structObjects.push_back(uobj);
                    structCount++;
                    break;

                case ObjectType::OTHER:
                default:
                    obj << "[OBJECT] " << objectName << " (" << className << ")" << std::endl;
                    otherCount++;
                    break;
                }
            }
        }

        // dump 所有枚举、类、函数和结构体
        if (!enumObjects.empty())
        {
            std::cout << "[3.1] Processing " << enumObjects.size() << " enums..." << std::endl;
            ProcessAllEnums(outputpath, enumObjects);
        }

        if (!classObjects.empty())
        {
            std::cout << "[3.2] Processing " << classObjects.size() << " classes..." << std::endl;
            ProcessAllClasses(outputpath, classObjects);
        }

        if (!functionObjects.empty())
        {
            std::cout << "[3.3] Processing " << functionObjects.size() << " functions..." << std::endl;
            ProcessAllFunctions(outputpath, functionObjects);
        }

        if (!structObjects.empty())
        {
            std::cout << "[3.4] Processing " << structObjects.size() << " structs..." << std::endl;
            ProcessAllStructs(outputpath, structObjects);
        }

        obj << "\n====== Statistics ======" << std::endl;
        obj << "Actors: " << std::dec << actorCount << std::endl;
        obj << "Enums: " << enumCount << std::endl;
        obj << "Classes: " << classCount << std::endl;
        obj << "Functions: " << functionCount << std::endl;
        obj << "Structs: " << structCount << std::endl;
        obj << "Others: " << otherCount << std::endl;
        obj << "Total: " << (actorCount + enumCount + classCount + functionCount + structCount + otherCount)
            << std::endl;

        std::cout << std::dec << "Actors: " << actorCount << ", Enums: " << enumCount << ", Classes: " << classCount
                  << ", Functions: " << functionCount << ", Structs: " << structCount << ", Others: " << otherCount
                  << std::endl;
    }
}

void DumpObjects(std::string outputpath)
{
    std::ofstream obj(outputpath + "/Objects.txt", std::ofstream::out);
    if (obj.is_open())
    {
        int32 count = GetObjectCount();
        std::cout << "[3] Dumping Objects ---" << std::endl;
        std::cout << "Total Objects: " << count << std::endl;

        obj << "/*\n"
            << " * Generated by czTang\n"
            << " * Generated on: " << Tools::getCurrentTimeString() << "\n"
            << " */\n"
            << std::endl;

        for (int32 i = 0; i < count; i++)
        {
            kaddr uobj = GetUObjectFromID(i);
            if (UObject::isValid(uobj))
            {
                kaddr classPtr = UObject::getClass(uobj);
                std::string className = UObject::getClassName(uobj);
                std::string objectName = UObject::getName(uobj);
                obj << "Ptr: 0x" << std::hex << uobj << " " << className << " " << objectName << std::endl;
            }
        }
    }
}

void ProcessAllEnums(std::string outputpath, const std::vector<kaddr> &enumObjects)
{
    std::ofstream enumFile(outputpath + "/Enum.hpp", std::ofstream::out);
    if (!enumFile.is_open())
    {
        std::cerr << "Failed to open Enums.hpp for writing!" << std::endl;
        return;
    }

    enumFile << "/*\n"
             << " * Generated by czTang\n"
             << " * Generated on: " << Tools::getCurrentTimeString() << "\n"
             << " */\n";

    for (kaddr enumObj : enumObjects)
    {
        std::string enumName = UObject::getName(enumObj);
        uint32_t enumCount = UEnum::getCount(enumObj);
        kaddr enumNamesArray = UEnum::getNameArray(enumObj);
        uint32 maxCount = 0;

        // 预扫描获取 enum 最大值，从而确定类型
        for (uint32 i = 0; i < enumCount; i++)
        {
            uint32 enum_num = Tools::Read<uint32>(enumNamesArray + i * Offsets.TPair.Size + Offsets.TPair.Value);
            if (enum_num > maxCount)
                maxCount = enum_num;
        }
        std::string Type = (maxCount > 255) ? "uint32" : "uint8";

        enumFile << "\n// " << UObject::getClassName(enumObj) << " " << GetOuterFullName(enumObj) << std::endl
                 << "enum class " << enumName << " : " << Type << "\n{" << std::endl;

        // 遍历枚举值，获取名称和数值
        for (uint32 i = 0; i < enumCount; i++)
        {
            uint32 index = Tools::Read<uint32>(enumNamesArray + i * Offsets.TPair.Size + Offsets.TPair.Key);
            uint32 enum_num = Tools::Read<uint32>(enumNamesArray + i * Offsets.TPair.Size + Offsets.TPair.Value);

            std::string enumValueName = GetFNameFromID(index);
            std::string prefix = enumName + "::";
            if (enumValueName.find(prefix) == 0)
            {
                enumValueName = enumValueName.substr(prefix.length());
            }

            enumFile << "\t" << std::left << std::setw(40) << enumValueName << " = " << enum_num << ",\n";
        }
        enumFile << "};\n";
    }
}

void ProcessAllClasses(std::string outputpath, const std::vector<kaddr> &classObjects)
{
    std::ofstream classFile(outputpath + "/Class.hpp", std::ofstream::out);
    if (!classFile.is_open())
    {
        std::cerr << "Failed to open CLass.hpp for writing!" << std::endl;
        return;
    }

    classFile << "/*\n"
              << " * Generated by czTang\n"
              << " * Generated on: " << Tools::getCurrentTimeString() << "\n"
              << " */\n";

    for (kaddr classObj : classObjects)
    {
        int pos = 0;
        std::string className = UStruct::getCPPName(classObj);
        uint32 classSize = UStruct::getPropertiesSize(classObj);
        kaddr superClass = UStruct::getSuperClass(classObj);
        if (superClass)
        {
            pos = UStruct::getPropertiesSize(superClass);
        }

        classFile << "\n// " << UObject::getClassName(classObj) << " " << GetOuterFullName(classObj) << std::endl
                  << "// Class Size: 0x" << std::hex << classSize << std::endl;
        classFile << "class " << className << " : public " << UStruct::getCPPName(superClass) << std::endl
                  << "{" << std::endl;

        // 遍历类的所有属性
        for (kaddr prop = UStruct::getChildProperties(classObj); prop; prop = FField::getNext(prop))
        {
            std::string oname = FField::getName(prop);
            std::string cname = FField::getClassName(prop);
            uint32 offset = FProperty::getOffset(prop);
            uint32 size = FProperty::getElementSize(prop);
            std::string formattedType = FormatPropertyType(prop);

            // 填充不连续属性
            if (pos < offset)
            {
                int diff = offset - pos;
                char paddingName[64];
                sprintf(paddingName, "padding[0x%04X];", diff);

                std::ostringstream paddingLine;
                paddingLine << "\t" << std::left << std::setw(50) << "char" << std::left << std::setw(50) << paddingName
                            << "// 0x" << std::right << std::setfill('0') << std::setw(4) << std::hex << std::uppercase
                            << pos << "(0x" << std::setfill('0') << std::setw(4) << std::hex << std::uppercase << diff
                            << ")";

                classFile << paddingLine.str() << std::endl;
            }

            std::ostringstream line;
            line << "\t" << std::left << std::setw(50) << formattedType << std::left << std::setw(50) << (oname + ";")
                 << "// 0x" << std::right << std::setfill('0') << std::setw(4) << std::hex << std::uppercase << offset
                 << "(0x" << std::setfill('0') << std::setw(4) << std::hex << std::uppercase << size << ")";
            classFile << line.str() << std::endl;

            pos = offset + size;
        }

        // 最后填充到类大小
        if (pos < classSize)
        {
            int diff = classSize - pos;

            char paddingName[64];
            sprintf(paddingName, "padding[0x%04X];", diff);

            std::ostringstream paddingLine;
            paddingLine << "\t" << std::left << std::setw(50) << "char" << std::left << std::setw(50) << paddingName
                        << "// 0x" << std::right << std::setfill('0') << std::setw(4) << std::hex << std::uppercase
                        << pos << "(0x" << std::setfill('0') << std::setw(4) << std::hex << std::uppercase << diff
                        << ")";

            classFile << paddingLine.str() << std::endl;
        }
        classFile << "};\n";
    }
}

void ProcessAllFunctions(std::string outputpath, const std::vector<kaddr> &functionObjects)
{
    std::ofstream functionFile(outputpath + "/Function.hpp", std::ofstream::out);
    if (!functionFile.is_open())
    {
        std::cerr << "Failed to open Function.hpp for writing!" << std::endl;
        return;
    }

    functionFile << "/*\n"
                 << " * Generated by czTang\n"
                 << " * Generated on: " << Tools::getCurrentTimeString() << "\n"
                 << " */\n";

    // 将函数对象按类名分组，从而生成类的函数列表
    std::map<std::string, std::vector<kaddr>> classFunctionMap;
    for (kaddr funcObj : functionObjects)
    {
        std::string className = UStruct::getCPPName(UObject::getOuter(funcObj));
        std::string functionName = UObject::getName(funcObj);

        if (Tools::isContain(functionName, "Delegate") || Tools::isContain(functionName, "Default__"))
            continue;

        classFunctionMap[className].push_back(funcObj);
    }

    for (const auto &[className, functions] : classFunctionMap)
    {
        if (functions.empty())
            continue;

        functionFile << "\nclass " << className << "\n{\n";

        for (kaddr funcObj : functions)
        {
            std::string functionName = UObject::getName(funcObj);
            std::string returnVal = "void";
            std::string params = "";

            // 处理函数的参数和返回值
            for (kaddr funcParam = UStruct::getChildProperties(funcObj); funcParam;
                 funcParam = FField::getNext(funcParam))
            {
                uint64 PropertyFlags = FProperty::getPropertyFlags(funcParam);

                if (PropertyFlags & 0x0000000000000400)
                {
                    returnVal = FormatPropertyType(funcParam);
                }
                else
                {
                    std::string paramStr = "";

                    if (PropertyFlags & 0x0000000000000002)
                        paramStr += "const ";
                    if (PropertyFlags & 0x0000000000000100)
                        paramStr += "out ";
                    if (PropertyFlags == 0x0000000000000000)
                        paramStr += "ref ";

                    paramStr += FormatPropertyType(funcParam) + " " + FField::getName(funcParam);

                    if (!params.empty())
                        params += ", ";
                    params += paramStr;
                }
            }

            if (UFunction::getFunctionFlags(funcObj) & 0x00002000)
                functionFile << "\tstatic ";
            else
                functionFile << "\t";

            functionFile << returnVal << " " << functionName << "(" << params << ")"
                         << " // 0x" << std::hex << UFunction::getFunc(funcObj) - Tools::lib_range.base << "\n";
        }
        functionFile << "};\n\n";
    }
}

void ProcessAllStructs(std::string outputpath, const std::vector<kaddr> &structObjects)
{
    std::ofstream structFile(outputpath + "/Struct.hpp", std::ofstream::out);
    if (!structFile.is_open())
    {
        std::cerr << "Failed to open Struct.hpp for writing!" << std::endl;
        return;
    }

    structFile << "/*\n"
               << " * Generated by czTang\n"
               << " * Generated on: " << Tools::getCurrentTimeString() << "\n"
               << " */\n";

    for (kaddr structObj : structObjects)
    {
        int pos = 0;
        std::string structName = UStruct::getCPPName(structObj);
        uint32 structSize = UStruct::getPropertiesSize(structObj);
        kaddr superClass = UStruct::getSuperClass(structObj);
        if (superClass)
        {
            pos = UStruct::getPropertiesSize(superClass);
        }

        structFile << "\n// " << UObject::getClassName(structObj) << " " << GetOuterFullName(structObj) << std::endl
                   << "// Struct Size: 0x" << std::hex << structSize << std::endl;
        structFile << "class " << structName << " : public " << UStruct::getCPPName(superClass) << std::endl
                   << "{" << std::endl;

        // 遍历结构体的所有属性
        for (kaddr prop = UStruct::getChildProperties(structObj); prop; prop = FField::getNext(prop))
        {
            std::string oname = FField::getName(prop);
            std::string cname = FField::getClassName(prop);
            uint32 offset = FProperty::getOffset(prop);
            uint32 size = FProperty::getElementSize(prop);
            std::string formattedType = FormatPropertyType(prop);

            // 计算并输出填充数组
            if (pos < offset)
            {
                int diff = offset - pos;
                char paddingName[64];
                sprintf(paddingName, "padding[0x%04X];", diff);

                std::ostringstream paddingLine;
                paddingLine << "\t" << std::left << std::setw(50) << "char" << std::left << std::setw(50) << paddingName
                            << "// 0x" << std::right << std::setfill('0') << std::setw(4) << std::hex << std::uppercase
                            << pos << "(0x" << std::setfill('0') << std::setw(4) << std::hex << std::uppercase << diff
                            << ")";

                structFile << paddingLine.str() << std::endl;
            }

            std::ostringstream line;
            line << "\t" << std::left << std::setw(50) << formattedType << std::left << std::setw(50) << (oname + ";")
                 << "// 0x" << std::right << std::setfill('0') << std::setw(4) << std::hex << std::uppercase << offset
                 << "(0x" << std::setfill('0') << std::setw(4) << std::hex << std::uppercase << size << ")";
            structFile << line.str() << std::endl;

            pos = offset + size;
        }

        if (pos < structSize)
        {
            int diff = structSize - pos;

            char paddingName[64];
            sprintf(paddingName, "padding[0x%04X];", diff);

            std::ostringstream paddingLine;
            paddingLine << "\t" << std::left << std::setw(50) << "char" << std::left << std::setw(50) << paddingName
                        << "// 0x" << std::right << std::setfill('0') << std::setw(4) << std::hex << std::uppercase
                        << pos << "(0x" << std::setfill('0') << std::setw(4) << std::hex << std::uppercase << diff
                        << ")";

            structFile << paddingLine.str() << std::endl;
        }
        structFile << "};\n";
    }
}